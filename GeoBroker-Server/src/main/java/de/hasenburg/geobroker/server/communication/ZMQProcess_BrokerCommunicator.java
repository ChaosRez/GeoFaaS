package de.hasenburg.geobroker.server.communication;

import de.hasenburg.geobroker.commons.communication.ZMQControlUtility;
import de.hasenburg.geobroker.commons.communication.ZMQProcess;
import de.hasenburg.geobroker.commons.model.BrokerInfo;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.zeromq.SocketType;
import org.zeromq.ZContext;
import org.zeromq.ZMQ;
import org.zeromq.ZMQ.Socket;
import org.zeromq.ZMsg;

import java.util.ArrayList;
import java.util.List;

class ZMQProcess_BrokerCommunicator extends ZMQProcess {

	private static final Logger logger = LogManager.getLogger();

	private final int PULL_INDEX = 0; // the pull socket
	private final int SOCKET_OFFSET = 1; // we have one other socket that is not a dealer broker socket
	private List<BrokerInfo> otherBrokerInfos;

	/**
	 * @param identity - must be unique across all brokers
	 */
	ZMQProcess_BrokerCommunicator(String identity, List<BrokerInfo> otherBrokerInfos) {
		super(identity);
		this.otherBrokerInfos = otherBrokerInfos;
	}

	/**
	 * @param identifier - identifier of the target ZMQProcess_BrokerCommunicator
	 * @return the zmq address other sockets can connect to
	 */
	public static String getBrokerCommunicatorAddress(String identifier) {
		return "\"inproc://\" + identity";
	}

	@Override
	protected List<Socket> bindAndConnectSockets(ZContext context) {
		List<Socket> socketList = new ArrayList<>(otherBrokerInfos.size() + SOCKET_OFFSET);

		// bind pull socket
		Socket puller = context.createSocket(SocketType.PULL);
		puller.setIdentity(identity.getBytes());
		puller.bind(ZMQProcess_BrokerCommunicator.getBrokerCommunicatorAddress(identity));
		socketList.add(puller);

		// bind dealer sockets
		int i = 0;
		for (BrokerInfo brokerInfo : otherBrokerInfos) {
			Socket dealer = context.createSocket(SocketType.DEALER);
			dealer.setIdentity((identity + "-" + i).getBytes());
			dealer.connect(brokerInfo.getAddress() + ":" + brokerInfo.getPort());
			socketList.add(dealer);
			i++;
		}

		return socketList;
	}

	@Override
	protected void processZMQControlCommandOtherThanKill(ZMQControlUtility.ZMQControlCommand zmqControlCommand,
														 ZMsg msg) {
		// no other commands are of interest
	}

	/*****************************************************************
	 * Process polled messages
	 ****************************************************************/

	@Override
	protected void processZMsg(int socketIndex, ZMsg msg) {
		if (PULL_INDEX == socketIndex) {
			processPULLSocketMessage(msg);
			return;
		}

		int dealerIndex = socketIndex - SOCKET_OFFSET;

		if (otherBrokerInfos.size() - 1 < dealerIndex) {
			processDEALERSocketMessage(msg);
			return;
		}

		logger.error("Received a message on socket {}, but there should not be a socket.", socketIndex);
	}

	/**
	 * @param msg - should be generated by {@link ZMQProcess_BrokerCommunicator#generatePULLSocketMessage(String,
	 * InternalBrokerMessage)}
	 */
	private void processPULLSocketMessage(ZMsg msg) {
		String targetBrokerId = null;

		// get the target brokerId
		if (msg != null && msg.size() == 3) { // target broker id + two parts for InternalBrokerMessage
			targetBrokerId = msg.pop().getString(ZMQ.CHARSET);
		}

		if (targetBrokerId == null) {
			logger.error("Message is missing target broker id");
			return;
		}

		logger.trace("Sending a message to broker {}", targetBrokerId);
		int socketIndex = getSocketIndexForBrokerId(targetBrokerId);

		if (socketIndex < 0) {
			logger.error("Broker {} does not have a socket.", socketIndex);
		}

		Socket socket = sockets.get(socketIndex);

		// send the remaining msg, which should equal an InternalBrokerMessage now that the target brokerId got removed
		msg.send(socket); // we do not check each time whether the message is an InternalBrokerMessage for performance reasons
	}

	private void processDEALERSocketMessage(ZMsg msg) {
		// TODO process replies of dealers
	}

	/*****************************************************************
	 * Message Generation Helpers
	 ****************************************************************/

	public static ZMsg generatePULLSocketMessage(String targetBrokerId, InternalBrokerMessage ibm) {
		ZMsg msg = ZMsg.newStringMsg(targetBrokerId);
		ZMsg ibm_message = ibm.getZMsg();
		msg.add(ibm_message.pop());
		msg.add(ibm_message.pop());
		if (ibm_message.size() > 0) {
			logger.error("All message frames should have been popped.");
		}
		return msg;
	}

	/*****************************************************************
	 * Others
	 ****************************************************************/

	@Override
	protected void shutdownCompleted() {
		logger.info("Shut down ZMQProcess_Server {}", identity);
	}

	private int getSocketIndexForBrokerId(String brokerId) {
		// TODO make more efficient
		int i = SOCKET_OFFSET; // first socket is at this index
		for (BrokerInfo otherBrokerInfo : otherBrokerInfos) {
			if (otherBrokerInfo.getBrokerId().equals(brokerId)) {
				return i;
			}
			i++;
		}
		return -1;
	}

}
